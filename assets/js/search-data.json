{
  
    
        "post0": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://jimypbr.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jimypbr.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "How to do Polymorphism in Clojure (3/3)",
            "content": "This post is composed of 3 parts: Part 1, Part 2, Part 3 . Arithmetic with Mixed Types . We have so far built a number system with five different types and an add function that can take any two numbers of the same type and add them together with the same interface. . However what if I wanted to add a Complex-r and a Real together? We would need to convert the Real to a Complex-r and then add them together. We could do this by adding more multimethods: . (defmethod add [::complex-r ::real] (...)) (defmethod add [::real ::complex-r] (...)) . You can see that doing this for all combinations of types would lead to a combinatorial explosion of new multimethods! Clojure’s hierarchies can enable us to solve this problem without the need to write a factorial number of functions. . We can side-step the problem of writing a combinatorical number of new functions by noting that to add two different types of number together we have to promote one of the numbers to be the same type as the other. With this in mind we can create a catch-all method for add that catches all the cases of mixed types, coerces the types to be the same and then calls add again with the converted types. It will then call one of the previously defined add methods where the types are the same. . We can implement the catch-all case by creating a new abstraction ::number at the top of the hierarchy where every number we have created so far is a descendant of ::number: . (derive ::complex ::number) (derive ::integer ::number) (derive ::float ::number) (derive ::rational ::number) . We can now create the catch-all add method that will that will matc [::number ::number]: . (defmethod add [::number ::number] [n1 n2] (apply add (coerce-types n1 n2))) . This works because any combination of different types will fail all the rules of the other multimethods except this one, because all of our types are descendants of ::number. This method then calls the coercion function (which I will define later) to convert the arguments into the same type and then calls the add multi-function with these converted arguments. This will then find the correct multimethod for the now uniform types return the result. . Type Coercion with the Numeric Tower . We can convert any Integer to a Rational without a loss of information. You cannot convert any Rational to an Integer without a loss of information though. Similarly any Rational can be converted to a Float, and any Float can be converted to a Complex number. . This chain of conversions is the numeric tower: . Integer -&gt; Rational -&gt; Float -&gt; Complex | . We want to be able to call a function raise on one of our types and get back the same numeric value, but represent by the next type in the tower. The function depends on the type of the argument so we can create another protocol: . (defprotocol PRaise (raise [x] &quot;raises a number type to the next type in the numeric tower with equivalent value&quot;)) (extend-protocol PRaise Int (raise [x] (rational (:n x) 1)) Rational (raise [x] (float (/ (numer x) (double (denom x))))) Float (raise [x] (complex-r (:n x) 0))) . Given a pair of types, e.g. [::integer ::float], we need a way to encode the fact that ::float is higher in the tower than ::integer, and so ::integer needs to be raised until it is a ::float. This could be done with a map associating the types to a rank number, but this is pretty inflexible if we add more types. . The numeric tower is a hierarchy so we are actually better off using Clojure’s ad-hoc hierarchies again. In Clojure there is a global hierarchy structure which we have used so far for the arithmetic, but you are free to create your own hierarchies with make-hierarchy. This exists independently of the global hierarchy we used earlier. This is handy because the numeric tower hierarchy is different from the arithmetic hierarchy. . (def numeric-tower (-&gt; (make-hierarchy) (derive ::complex ::complex-p) (derive ::complex ::complex-r) (derive ::float ::complex) (derive ::rational ::float) (derive ::integer ::rational))) . Using this we can create comparator functions for two keyword types. For example: . =&gt; (higher? ::float ::integer) true =&gt; (lower? ::rational ::complex-r) true . These are easy to implement using the functions for querying hierarchies, ancestors and descendents: . (defn higher? &quot;Is type 1 higher in the numeric tower than type 2?&quot; [t1 t2] (if (contains? (ancestors numeric-tower t2) t1) true false)) (defn lower? &quot;Is type 1 lower in the numeric tower than type 2?&quot; [t1 t2] (if (contains? (descendants numeric-tower t2) t1) true false)) . With these functions we can implement coerce-types: . (defn coerce-types &quot;Given two different number types raise the lesser type up to be the same as the greater type&quot; [x y] (let [t1 (kind x) t2 (kind y)] (cond (lower? t1 t2) (recur (raise x) y) (higher? t1 t2) (recur x (raise y)) :else [x y]))) . Trying this out in a REPL: . =&gt; (raise (integer 3)) #numbers.core.Rational{:n 3, :d 1} =&gt; (raise (float 4)) #numbers.core.Complex-r{:real 4.0, :imag 0} =&gt; (coerce-types (integer 4) (rational 5 6)) [#numbers.core.Rational{:n 4, :d 1} #numbers.core.Rational{:n 5, :d 6}] =&gt; (coerce-types (rational 5 6) (complex-r 7 8)) [#numbers.core.Complex-r{:real 0.8333333333333333, :imag 0} #numbers.core.Complex-r{:real 7, :imag 8}] . Final Product and Further Ideas . We have implemented a number system that can represent integers, floating point numbers, rational numbers, rectangular complex numbers, and polar complex numbers. It can perform basic binary arithmetic operations add, subtract, multiply, and divide on any combination of number types. . Let’s demonstrate the final product in the REPL: . (add (integer 4) (integer 6)) #numbers.core.Int{:n 10} (add (integer 4) (float 6)) #numbers.core.Float{:n 10.0} (add (rational 5 6) (float 6)) #numbers.core.Float{:n 6.833333333333333} (mul (float 6) (complex-p 10 0.5)) #numbers.core.Complex-p{:magnitude 60.0, :angle 0.5} (div (integer 5) (rational 7 5)) #numbers.core.Rational{:n 25, :d 7} (div (integer 5) (complex-r 7 5)) #numbers.core.Complex-p{:magnitude 0.5812381937190965, :angle -0.6202494859828215} . Seems to work fairly well! . I could continue building on this, but that would be beyond the scope of this blog post. There are a few things worth thinking about nonetheless. One aesthetic improvement would be implementing a pretty REPL representation of the custom number types. E.g. having 3/4 instead of Rational(:n 3 :d 4). Clojure has a single function that takes care of printing things: clojure.lang.print-method. This is simply another multimethod like we’ve already been using. Adding nicer printing is straight-forward: . ;; nicer printing for rationals (defmethod print-method Rational [x ^java.io.Writer writer] (.write writer (str (numer x) / (denom x)))) ;; and similarly for the other types... ;; ... . In SICP there is also an exercise to extend the number system to be implemented purely with its own types. So while Integer and Float types would be wrappers for Clojure’s own types, the Rational, Complex-r, and Complex-p types could themselves be composed of any of the other types. So you could have a Rational number whose demoninator and numerator were complex numbers. Or conversely a complex number whose real and imaginary parts were rational numbers. This would be achieved with some modification to the existing code. You would need to replace all uses of Clojure’s primitive arithmetic functions (+, *, etc.) with our multimethods (add, mult, etc), and also create our own implementations of sqrt, sin, cos, and atan that handled our number types. This could be done by adding new protocols. . Final Thoughts . This is a nice non-trivial program from SICP that demonstrates the ideas and challenges in polymorphism. Implementing this in Clojure required us to use just about every feature for polymorphism in Clojure’s core library. But I am satified with how Clojure could handle everything without any requiring any ‘hacks’ or major redesigns. . I think that this highlights one of the good aspects of Clojure’s design and philosophy. Namely, the decoupling (or ‘decomplecting’) of ideas in the language. In this demo there are the following concepts: . Data (in the form of records). | Functions. | Single and multiple dispatch (protocols and multimethods) to functions. | Hierarchies of types. | Functions and data are decoupled because records are just data and you can’t attach methods onto records in Clojure the way you can with class methods in OOP. You don’t need getter/setter methods because records are maps so you just the functions for maps. . Data and dispatch are decoupled. You do not need to know at design time which protocols or multimethods are going to use your record type. In Java where polymorphic single-dispatch is achieved via interfaces or abstract classes you need explicitly implement or extend your class when you write it. In Clojure you can add protocols or multimethods to any existing type when are where you want. . Dispatch in Clojure is simply a fancy wrapper for functions. For a user of a protocol, multimethod, or function it makes no difference how it is implemented - it looks exactly the same. This is a big win for extending or refactoring code without breaking things. For example, say we only had a complex type complex-r and implemented the methods real, imag, magnitude, and angle as functions via defn. But then later we required the complex-p type and it also needed the same methods. Refactoring the existing functions (real, imag, etc) into a protocol will make no difference to code already using these functions with the complex-r type - it looks and acts just like a function. Multimethods are the same. . Type hierarchies can be decoupled from types. In this example we built a hierarchy for the number types using namespaced keywords like ::complex-r. This exists independently from the records we defined. It is coupled to the record types via a one-to-one mapping of the records to a keyword, implemented by the protocol PNumberKind. This decoupling allowed us to create further abstractions such as ::number and ::complex. In Java you’d have to create abstract base classes retroactively and subclass the existing types, which would be a redesign. This decoupling was also useful later for the numeric tower where we actually required a completely different hierarchy of the types. This was made possible in Clojure because you can create multiple hierarchies ad-hoc - hierarchies are just data. You could even implement multimethods with different type hierarchies this way. In OOP this kind of polymorphic dispatch is strongly coupled to your class hierarchies, which you can’t just change. . Source Code . The complete source code of this tutorial can be found here: jimypbr/clojure-numbers. . References and Further Reading . SICP section 2.4 | Watch ‘Simple Made Easy’ by Rich Hickey. It’s a great talk that explains how Clojure aims to decouple key programming concepts from each other: Simple Made Easy, Rich Hickey | For more about multiple dispatch, Eli Bendersky’s series of blog posts are great: http://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch | This post is composed of 3 parts: Part 1, Part 2, Part 3 .",
            "url": "https://jimypbr.github.io/blog/clojure/functional-programming/2016/11/23/polyclojure3.html",
            "relUrl": "/clojure/functional-programming/2016/11/23/polyclojure3.html",
            "date": " • Nov 23, 2016"
        }
        
    
  
    
        ,"post3": {
            "title": "How to do Polymorphism in Clojure (2/3)",
            "content": "This post is composed of 3 parts: Part 1, Part 2, Part 3 . More Number Types . Let’s extend our number package with more number types: An Integer type, a Float type for real numbers, and a Rational type for fractions. Like before we create the records and constructors: . (defrecord Int [n]) (defrecord Rational [n d]) (defrecord Float [n]) ;; constructors (defn integer &quot;Make a new integer&quot; [n] {:pre [(number? n)]} (-&gt;Int (int n))) (defn float &quot;Make a new float&quot; [n] {:pre [(number? n)]} (-&gt;Float (double n))) (defn rational &quot;Make a new rational&quot; [n d] {:pre [(number? n) (number? d)]} (let [g (gcd n d)] (-&gt;Rational (/ n g) (/ d g)))) . Trying these out in the REPL: . =&gt; (float 3) #numbers.core.Float{:n 3.0} =&gt; (integer 6) #numbers.core.Int{:n 4} =&gt; (rational 6 3) #numbers.core.Rational{:n 2, :d 1} . Generic Arithmetic . We want to create an add function that can be called with either two integers, two rationals, two reals, or two complex types and do the right thing in every case. Protocols in Clojure allow for single dispatch only. Here we need to dispatch on the types of multiple arguments. . We could hack this with a mega-function that is just a big conditional statement: . (def mega-add &quot;one add to rule them all (don&#39;t do this)&quot; [n1 n2] (cond (and (= (type n1) Int) (= (type n2) Int)) (add-int n1 n2) (and (= (type n1) Float) (= (type n2) Float) (add-real n1 n2) ;; etc :else (throw &quot;unknown types&quot;))) . The problem with this solution is that it is closed for business. If a user of the our number library desired to extend the number system with a new type of number (e.g. a BigInt), they’d have to break in and edit this function directly. . Multi-Methods . Clojure’s core library provides multiple dispatch via multi-methods. While protocols in Clojure perform single-dispatch on just the type of the first argument, multi-methods are much more general and allow the programmer to define their own rules for dispatch using any number of arguments. You are not limited to dispatch with just the types of the arguments, but also their values. . Let’s throw out mega-add and do it properly with multi-methods. The multi-method is defined using the defmulti macro. It takes a docstring and a dispatch function as its arguments. For adding, the dispatch function will be mapped to the two numbers as arguments and so return a vector of the types of the arguments: . (defmulti add &quot;Generic add&quot; class) . So if we provided two Ints then the dispatch would return [Int Int]. With the dispatch machinery is in place, we now need to add the implementations for each of the types. This is done with defmethod, which defines a method for each valid output of the dispatch function: . (defmethod add [Int Int] &quot;Add two integers together&quot; [n1 n2] (integer (+ (:n n1) (:n n2)))) (defmethod add [Float Float] &quot;Add two floats together&quot; [n1 n2] (float (+ (:n n1) (:n n2)))) ;; etc . Trying this out in the repl: . =&gt; (add (integer 4) (integer 6)) #numbers.core.Int{:n 10} =&gt; (add (float 5) (float 10)) #numbers.core.Float{:n 15.0} . Neat! Multi-methods are easy to extend too. If I wanted to create a new number type (e.g. a BigInt), then all I need to do is add a new method with defmethod for the case of [BigInt BigInt]. . Similarly we can reimplement the add function defined previously for the two complex number types, using the new multi-method machinery: . (defmethod add [Complex-r Complex-r] &quot;Add two complex-r numbers together&quot; [z1 z2] (complex-r (+ (real z1) (real z2)) (+ (imag z1) (imag z2))) (defmethod add [Complex-p Complex-p] &quot;Add two complex-p numbers together&quot; [z1 z2] (complex-r (+ (real z1) (real z2)) (+ (imag z1) (imag z2))) . This works fine, but previously add for the two different complex number types was a single function, whereas now we have repetition. Moreover we can’t add a Complex-r to a Complex-p like we could before. . Multimethods have provided a lot of extensibility to new number types, but at the same time we have lost the polymorphic nature we had in the arithmetic functions of the two complex types. I will address this problem in the next section. . Keywords and Dispatch Hierarchies . We have an impression that Complex-r and Complex-p are subtypes of some imaginary abstract type Complex. However Clojure does not offer any notion of an ‘abstract type’ as we are used to in OOP. Instead Clojure provides an ad-hoc dynamic hierarchy system. The hierarchy system supports derivation relationships between names (either symbols or keywords), and relationships between classes and names. . The derive function creates these relationships, and the isa? function tests for their existence. We will use namespaced keywords (double colon) to represent the number types: . =&gt; (derive ::complex-r ::complex) =&gt; (derive ::complex-p ::complex) =&gt; (isa? ::complex-r ::complex) true =&gt; (isa? ::complex-p ::complex) true =&gt; (isa? ::complex-r ::complex-p) false =&gt; (ancestors ::complex-r) #{::complex} =&gt; (ancestors ::complex-p) #{::complex} . What we want to do is rewrite the arithmetic multi-methods to dispatch using these namespaced keywords in place of the number types. The complex add method could then be reduced to matching arguments that satisfy: [::complex ::complex]. To do this, we will require a one-to-one mapping of each type to its associated keyword: . Complex-r =&gt; ::complex-r | Complex-p =&gt; ::complex-p | Float =&gt; ::float | Rational =&gt; ::rational | Int =&gt; ::integer | . We could do this with a global lookup table or add the keywords to the record definitions, but these are cludgy solutions. The first requires maintaining some global data, and the second repeats information and forces us to rewrite the record definition, which would break existing code. A cleaner solution is just to create another protocol and extend our number types with it: . (defprotocol PNumberKind (kind [n] &quot;The keyword name for the kind of the number n&quot;)) (extend-protocol PNumberKind Complex-r (kind [z] ::complex-r) Complex-p (kind [z] ::complex-p) Float (kind [z] ::float) Rational (kind [z] ::rational) Int (kind [z] ::integer)) . In the REPL: . =&gt; (kind (integer 3)) :numbers.core/integer =&gt; (kind (complex-r 4 5)) :numbers.core/complex-r . We can now update the dispatch function used by the multimethod to dispatch using kind: . (defmulti add &quot;Generic add&quot; kind) . The methods can now be rewritten as: . (defmethod add [::integer ::integer] &quot;Add two integers together&quot; [n1 n2] (integer (+ (:n n1) (:n n2)))) (defmethod add [::float ::float] &quot;Add two reals together&quot; [n1 n2] (real (+ (:n n1) (:n n2)))) (defmethod add [::complex ::complex] &quot;Add two complex-p numbers together&quot; [z1 z2] (complex-r (+ (real z1) (real z2)) (+ (imag z1) (imag z2))) . Since we added the rule (derive ::complex-r ::complex) to the hierarchy, the multimethod called with ::complex-r or ::complex-p implicitly satisfy the rule [::complex ::complex]. The hierarchy has therefore allowed us the implement a polymorphic add for adding different representations of complex numbers and their combinations. If we added more complex number representations, the generic add method for complex numbers would accomodate them automatically without modification. . Let’s try this in the REPL: . =&gt; (add (complex-r 2 3) (complex-r 6 7)) #numbers.core.Complex-r{:real 8, :imag 10} =&gt; (add (complex-p 4 5) (complex-p 1 0)) #numbers.core.Complex-r{:real 2.1346487418529048, :imag -3.835697098652554} =&gt; (add (complex-p 3 4) (complex-r 5 6)) #numbers.core.Complex-r{:real 3.039069137409164, :imag 3.7295925140762156} . This post is composed of 3 parts: Part 1, Part 2, Part 3 .",
            "url": "https://jimypbr.github.io/blog/clojure/functional-programming/2016/11/22/polyclojure2.html",
            "relUrl": "/clojure/functional-programming/2016/11/22/polyclojure2.html",
            "date": " • Nov 22, 2016"
        }
        
    
  
    
        ,"post4": {
            "title": "How to do Polymorphism in Clojure (1/3)",
            "content": "This post is composed of 3 parts: Part 1, Part 2, Part 3 . Introduction . Through the years of use of conventional programming languages such as Python and C++, my thinking about programming was trapped within the Object Oriented model of these languages. When it came to solving a new problem my thinking would be dictated by how those languages wanted me to think and I was blind to any better way. It wasn’t until I came across the 1980s cult-classic “Structure and Interpretation of Computer Programs” (SICP) and the programming language Clojure that I started to see past thought models I had learned. One of the parts that was a real ‘Ah-ha!’ moment for me was the final section of Chapter 2 on “Data-directed programming”. This chapter was the clearest explanation of the problem of Polymorphism that I’d ever read… . The concern of this section is in implementing a system for calculating with different types of numbers (e.g. complex, integers, rationals, etc). Variants of this example are commonly used beginners books to Java and C++ in order to demonstrated how Object Oriented programming (OOP) can model data and abstractions. However SICP is not a language manual and doesn’t concern itself with showing how to make some feature of a language do what you want. It instead focuses on the problem of trying to model numbers itself, and then creates the necessary structures to solve this problem. SICP uses this problem to motivate the actual purpose of OOP and it then creates a basic implementation of Objects in scheme. The book then goes beyond OOP and implements multiple dispatch from scratch entirely in Scheme. . I found this to be such an enlightening exercise that I started thinking about how well other languages could solve this problem. In this blog post I want to implement the Numbers program in Clojure, a language that provides multiple dispatch. I think this is a non-trivial example that demonstrates every feature for polymorphism in Clojure’s core libraries. . Complex Numbers . A complex number, $z$ is a number expressed in the form $z=u+iv$, where $u$ and $v$ are real numbers and $i^2=-1$. $u$ is called the real part and $v$ is called the imaginary part. . We can represent a complex number as a pair $(u, v)$, called the rectangular form. . | An alternative representation is the polar form where the complex number is represented by the pair $(r, phi)$, where $r$ is the magntitude and $ phi$ is the angle. . | . Rectangular and polar forms are related via the following formulae: . [ begin{eqnarray} u &amp;=&amp; r cos phi v &amp;=&amp; r sin phi r &amp;=&amp; sqrt{u^2 + v^2} phi &amp;=&amp; tan^{-1}(v/u) end{eqnarray}] . In our Complex number package we want to support the following arithmetic operations on pairs of complex numbers: add, sub, mult, and div. . When adding or subtracting complex numbers it is natural to work with their rectangular coordinates: . [ begin{eqnarray} Re(z_1 + z_2) &amp;=&amp; Re(z_1) + Re(z_2) Im(z_1 + z_2) &amp;=&amp; Im(z_1) + Im(z_2) end{eqnarray}] . While when multiplying and dividing complex numbers it is more natural to work with the polar coordinates: . [ begin{eqnarray} Magnitude(z_1 cdot z_2) &amp;=&amp; Magnitude(z_1) cdot Magnitude(z_2) Angle(z_1 cdot z_2) &amp;=&amp; Angle(z_1) + Angle(z_2) end{eqnarray}] . The product is the vector obtained by stretching the length of $z_1$ by the length of $z_2$, and rotating the angle of $z_1$ by the angle of $z_2$. . So there are two different representations which are suitable for different operations. However we want to be able to do all the arithmetic operations on complex numbers regardless of which representation is used. . Rectangular Representation . How can we model this number pair using the tools in Clojure? Clojure allows us to create an object called a Record. A Record is basically a map with a name, a minimum set of keys that it is guaranteed to have, and a constructor. Here’s how we could create a rectangular complex number with records: . (defrecord Complex-r [real imag]) . You can create some Complex-r’s: . =&gt; (-&gt;Complex-r 2 3) #user.Complex-r{:real 2, :imag 3} =&gt; (-&gt;Complex-r -1 16) #user.Complex-r{:real -1, :imag 16} . With records it is good practice to create your own constructor to give you freedom to add post- and pre-conditions when a new record is created. This is just a wrapper function: . (defn complex-r &quot;create a new Complex-r&quot; [re im] {:pre [(number? re) (number? im)]} (-&gt;Complex-r re im)) . I provided some preconditions that assert that the parameters are a type of Clojure’s native number. We can access the real and imaginary parts of a Complex-r: . =&gt; (:real (complex-r 4 5)) 4 =&gt; (:imag (complex-r 4 5)) 5 . However, getting the real and imaginary parts of a complex number using the keywords seems to expose the implementation of Complex-r too much. Better practice would be to wrap those in some functions: . (defn real-r &quot;Get the real part of a complex-r number.&quot; [z] (:real z)) (defn imag-r &quot;Get the imaginary part of a complex-r number.&quot; [z] (:imag z)) . So now we have: . =&gt; (real-r (complex-r 4 5)) 4 =&gt; (imag-r (complex-r 4 5)) 5 . We can also view the magnitude and angle of a rectangular complex number using the formulae above: . (defn magnitude-r &quot;Magnitude of a complex-r number&quot; [z] (Math/sqrt (+ (square (real-r z)) (square (imag-r z))))) (defn angle-r &quot;Angle of a complex-r number&quot; [z] (Math/atan (/ (imag-r z) (real-r z)))) . In the REPL: . =&gt; (magnitude-r (complex-r 3 4)) 5.0 =&gt; (angle-r (complex-r 3 4)) 0.9272952180016121 . Polar Representation . Similarly, we can implement the Polar form of complex numbers as another record: . (defrecord Complex-p [magnitude angle]) (defn complex-p &quot;create a new Complex-p&quot; [magnitude angle] {:pre [(number? magnitude) (number? angle)]} (-&gt;Complex-p magnitude angle)) . Again for the Polar representation we need to write some functions that will give us real and imaginary parts, and the magnitude and angle of a polar number. . (defn real-p &quot;real part of a complex-p number&quot; [z] (* (:magnitude z) (Math/sin (:angle z)))) (defn imag-p &quot;imaginary part of a complex-p number&quot; [z] (* (:magnitude z) (Math/cos (:angle z)))) (defn magnitude-p &quot;magnitude of a complex-p number&quot; [z] (:magnitude z)) (defn angle-p &quot;angle of a complex-p number&quot; [z] (:angle z)) . In the REPL: . =&gt; (angle-p (complex-p 5 0.5)) 0.5 =&gt; (magnitude-p (complex-p 5 0.5)) 5 =&gt; (real-p (complex-p 5 0.5)) 4.387912809451864 =&gt; (imag-p (complex-p 5 0.5)) 2.397127693021015 . Single Dispatch with Protocols . At this point we have two different types of complex number representations and two sets of functions that are specialised to handle each type. This is obviously bad because a user of this numbers module has to pay attention at all times to whether they are using Complex-r or Complex-p types. They need to specialise whatever code they write with them. . Rather than having real-r and real-p functions we instead want to have a single function real that takes any type of complex number and performs dispatch at runtime based on the type of the argument it has received. I.e. dispatch based on the type of the first argument passed to the function. Dispatch based on a single argument is called single dispatch. . Clojure allows single dispatch through Protocols. A protocol is a named set of functions and their signatures, with no implementions. The functions dispatch on the type of their first argument, and thus must have at least one argument. Implementations of the protocol functions have to be written for each type implementing the protocol. They are very similar to Java interfaces, but with one important improvement: which protocols are implemented for a type is not a design time decesion by the code author, rather protocols can extend any type whenever and wherever you want. . We create a protocol for complex numbers using defprotocol: . (defprotocol PComplex (real [z] &quot;Real part of a complex number&quot;) (imag [z] &quot;Imaginary part of a complex number&quot;) (magnitude [z] &quot;Magnitude of a complex number&quot;) (angle [z] &quot;Angle of a complex number&quot;)) . Implement the PComplex protocol for each of our types: . (extend-protocol PComplex ;; implementation of methods for Complex-r type Complex-r (real [z] (:real z)) (imag [z] (:imag z)) (magnitude [z] (Math/sqrt (+ (square (real z)) (square (imag z)))) (angle [z] (Math/atan (/ (imag z) (real z)))) ;; implemention of methods for Complex-p type Complex-p (real [z] (* (:magnitude z) (Math/sin (:angle z)))) (imag [z] (* (:magnitude z) (Math/cos (:angle z)))) (magnitude [z] (:magnitude z)) (angle [z] (:angle z))) . Trying this out in a REPL: . =&gt; (def z1 (complex-r 5 6)) =&gt; (def z2 (complex-p 3 1)) =&gt; (real z1) 5 =&gt; (real z2) 1.6209069176044193 =&gt; (magnitude z1) 7.810249675906654 =&gt; (magnitude z2) 5 . With protocol we now have a generic set of functions for dealing with any type of complex number. If we created a new type of complex number then we’d simple make it implement the PComplex protocol. . Arithmetic With Complex Numbers . The PComplex protocol allows us to write code that works with complex numbers and does not need to worry whether whether they are rectangular or polar. We can now write single implementations the arithmetic functions add, sub, mult, and div using the formulas above. . (defn add &quot;Add two complex numbers together&quot; [z1 z2] (complex-r (+ (real z1) (real z2)) (+ (imag z1) (imag z2))) (defn sub &quot;Subtract two complex numbers from each other&quot; [z1 z2] (complex-r (- (real z1) (real z2)) (- (imag z1) (imag z2)))) (defn mult &quot;Multiply two complex numbers together&quot; [z1 z2] (complex-p (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2)))) (defn div &quot;Divide two complex numbers by each other&quot; [z1 z2] (complex-p (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2)))) . Since the functions from PComplex work transparently for both representations of complex numbers we only need to write one function for add and it works not only for both types, but also all combinations of them for free! . Let’s try it all out in the REPL: . =&gt; (add (complex-r 5 5) (complex-r 6 6)) #numbers.core.Complex-r{:real 11, :imag 11} =&gt; (mul (complex-r 5 5) (complex-r 5 5)) #numbers.core.Complex-p{:magnitude 50.00000000000001, :angle 1.5707963267948966} =&gt; (add (complex-p 5 0.1) (complex-p 10 0)) #numbers.core.Complex-r{:real 14.975020826390129, :imag 0.4991670832341408} =&gt; (mul (complex-p 5 0.1) (complex-p 10 0)) #numbers.core.Complex-p{:magnitude 50, :angle 0.1} =&gt; (add (complex-r 5 5) (complex-p 10 0)) #numbers.core.Complex-r{:real 15.0, :imag 5.0} =&gt; (mul (complex-r 5 5) (complex-p 10 0)) #numbers.core.Complex-p{:magnitude 70.71067811865476, :angle 0.7853981633974483} . Without the polymorphism obtained from the protocol we would have to write 16 separate functions instead of just these 4. Moreover, if we wanted to create more complex number representations there would be a combinatorial explosion in the number of arithmetic functions we’d need to write. . This post is composed of 3 parts: Part 1, Part 2, Part 3 .",
            "url": "https://jimypbr.github.io/blog/clojure/functional-programming/2016/11/21/polyclojure1.html",
            "relUrl": "/clojure/functional-programming/2016/11/21/polyclojure1.html",
            "date": " • Nov 21, 2016"
        }
        
    
  
    
        ,"post5": {
            "title": "Experiments with Julia",
            "content": "SIMD Support . Since version 0.3 Julia has some vectorisation capabilities that can exploit SIMD instructions when executing loops. It seems to require some nudging though. There are macros that are a bit like the pragmas in OpenMP. . Example 1. SAXPY . function saxpy(a::Float32, x::Array{Float32,1}, y::Array{Float32,1}) n = length(x) for i = 1:n y[i] += a*x[i] end end . Sadly, in version 0.3.10 this obvious candidate does not auto-vectorise. You can inspect how this code has compiled nicely in Julia by using the macros @code_llvm to see the LLVM IR or @code_native to see the ASM. The ASM produced is: . Source line: 48 mov R8, QWORD PTR [RSI + 16] xor R11D, R11D xor ECX, ECX cmp RCX, R8 jae 65 cmp RCX, QWORD PTR [RDI + 16] jae 55 lea R10, QWORD PTR [4*R11] mov RAX, QWORD PTR [RSI + 8] sub RAX, R10 mov RDX, QWORD PTR [RDI + 8] sub RDX, R10 movss XMM1, DWORD PTR [RDX] mulss XMM1, XMM0 addss XMM1, DWORD PTR [RAX] movss DWORD PTR [RAX], XMM1 dec R11 inc RCX cmp R9, RCX jne -72 pop RBP ret movabs RAX, 140636405232096 mov RDI, QWORD PTR [RAX] movabs RAX, 140636390845696 mov ESI, 48 call RAX . Note the scalar instructions movss, mulss, and addss. . Example 2: SAXPY + SIMD . To make it generate vectorised instructions you have to use the explicit vectorisation macros @simd and @inbounds macros. @simd gives the compiler license to vectorise without checking the legality of the transformation. @inbounds is an optimisation that turns off subscript checking, because subscript checking might throw an exception and so isn’t vectorisable. . function axpy(a::Float32, x::Array{Float32,1}, y::Array{Float32,1}) n = length(x) @simd for i = 1:n @inbounds y[i] += a*x[i] end end . This now compiles with SIMD instructions: . ... Source line: 48 mov R8, QWORD PTR [RDI + 8] mov R9, QWORD PTR [RSI + 8] xor EDI, EDI mov RSI, RAX and RSI, -8 je 79 pshufd XMM1, XMM0, 0 # xmm1 = xmm0[0,0,0,0] xor EDI, EDI lea RCX, QWORD PTR [4*RDI] mov RDX, R8 sub RDX, RCX movups XMM3, XMMWORD PTR [RDX] movups XMM2, XMMWORD PTR [RDX + 16] mulps XMM3, XMM1 mov RDX, R9 sub RDX, RCX movups XMM5, XMMWORD PTR [RDX] movups XMM4, XMMWORD PTR [RDX + 16] addps XMM5, XMM3 movups XMMWORD PTR [RDX], XMM5 mulps XMM2, XMM1 addps XMM2, XMM4 movups XMMWORD PTR [RDX + 16], XMM2 add RDI, -8 mov RCX, RSI add RCX, RDI jne -69 mov RDI, RSI sub RAX, RDI je 41 ... . Note the instructions movups, addps, mulps… (English: move, unaligned, packed, single-precision). Packed =&gt; Vector. . We can also see from the LLVM IR: . define void @julia_axpy_21664(float, %jl_value_t*, %jl_value_t*) { ... br label %vector.body vector.body: ; preds = %vector.body, %vector.ph %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ] %25 = getelementptr float* %20, i64 %index, !dbg !4955 %26 = bitcast float* %25 to &lt;4 x float&gt;* %wide.load = load &lt;4 x float&gt;* %26, align 4 %.sum18 = or i64 %index, 4 %27 = getelementptr float* %20, i64 %.sum18 %28 = bitcast float* %27 to &lt;4 x float&gt;* %wide.load9 = load &lt;4 x float&gt;* %28, align 4 %29 = getelementptr float* %24, i64 %index, !dbg !4955 %30 = bitcast float* %29 to &lt;4 x float&gt;* %wide.load10 = load &lt;4 x float&gt;* %30, align 4 %31 = getelementptr float* %24, i64 %.sum18 %32 = bitcast float* %31 to &lt;4 x float&gt;* %wide.load11 = load &lt;4 x float&gt;* %32, align 4 %33 = fmul &lt;4 x float&gt; %wide.load10, %broadcast.splat13 %34 = fmul &lt;4 x float&gt; %wide.load11, %broadcast.splat13 %35 = fadd &lt;4 x float&gt; %wide.load, %33 %36 = fadd &lt;4 x float&gt; %wide.load9, %34 store &lt;4 x float&gt; %35, &lt;4 x float&gt;* %26, align 4 store &lt;4 x float&gt; %36, &lt;4 x float&gt;* %28, align 4 %index.next = add i64 %index, 8 %37 = icmp eq i64 %index.next, %n.vec br i1 %37, label %middle.block, label %vector.body middle.block: ; preds = %vector.body, %if %resume.val = phi i64 [ 0, %if ], [ %n.vec, %vector.body ] %cmp.n = icmp eq i64 %15, %resume.val br i1 %cmp.n, label %L7, label %L ... . Timing of a function is easy to do: . x = rand(Float32, 10000000) y = rand(Float32, 10000000) a = float32(0.1) @time axpy(a,x,y) . However, you probably want to run this more than once since the first time you call a function, Julia JITs it so the timing won’t be representative. Here are the timings of axpy with and without @simd with length(x) == 10000000: . @simd? Time (s) . yes | 0.006527373 | . no | 0.013172804 | . Setup: Hardware: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz (AVX) Julia version: 0.3.11 . Example 3: SAXPY + Implicit vectorisation . In my experiments, I found that it is sometimes possible to get implicit vectorisation by using just @inbounds to disable bounds checking: . function axpy(a::Float32, x::Array{Float32,1}, y::Array{Float32,1}) n = length(x) for i = 1:n @inbounds y[i] += a*x[i] end end . This generates the same ASM as Example 2. Other simple cases have required @simd as well, so explicit vectorisation seems to be the only option at the moment. . SIMD Limitations in Julia . No SIMD functions. Function calls have to be inlined. Julia can manage to inline short functions itself. | Code must be type-stable. This means that there isn’t implicit type conversion in the loop. This will prevent vectorisation and probably make it run slow serially too. | SIMD macro doesn’t have the bells and whistles of the OpenMP SIMD pragma. | Doesn’t appear to be any way to specify alignment of memory. | No outer loop vectorisation. | I can’t find any diagnostic information about how things were optimised. | Does handle any branching besides some ifelse function. | . More Info on Vectorisation . See Intel page Vectorization in Julia. . Case Study: Fitzhugh-Nagamo PDE . Experiment with a non-trivial example of a PDE solver using the reaction-diffusion system described by: . [ begin{eqnarray} frac{ partial u}{ partial t} &amp;=&amp; a nabla^2 u + u - u^3 - v - k tau frac{ partial v}{ partial t} &amp;=&amp; b nabla^2 v + u - v end{eqnarray}] . With Neumann boundary conditions, boundary of [1,1]^2, N=100^2, and T=[0.,10.]. This example is based on this online python example. I implement this in C++ and Julia and compare the performance and the vectorisation. $y=x^2$. . Here is the code in Julia: . Click to expand… function fitzhugh_nagumo(size, T) # Define the constants const aa = 2.8e-4 const bb = 5.0e-3 const τ = 0.1 const κ = -0.005 const dx = 2.0 / size const dt = 0.9 * dx^2 / 2.0 const invdx2 = 1.0 / dx^2 const dt_τ = dt / τ # Random initial fields u_old = rand(Float64, (size,size)) v_old = rand(Float64, (size,size)) u_new = Array(Float64, (size,size)) v_new = Array(Float64, (size,size)) for t = 0.0 : dt : T for j = 2:size-1 for i = 2:size-1 Δu = invdx2 * (u_old[i+1,j] + u_old[i-1,j] + u_old[i,j+1] + u_old[i,j-1] - 4*u_old[i,j]) Δv = invdx2 * (v_old[i+1,j] + v_old[i-1,j] + v_old[i,j+1] + v_old[i,j-1] - 4*v_old[i,j]) u_new[i,j] = u_old[i,j] + dt * (aa*Δu + u_old[i,j] - u_old[i,j]*u_old[i,j]*u_old[i,j] - v_old[i,j] + κ) v_new[i,j] = v_old[i,j] + dt_τ * (bb*Δv + u_old[i,j] - v_old[i,j]) end end for i = 1:size u_new[i,1] = u_new[i,2] u_new[i,size] = u_new[i,size-1] v_new[i,1] = v_new[i,2] v_new[i,size] = v_new[i,size-1] end for j = 1:size u_new[1,j] = u_new[2,j] u_new[size,j] = u_new[size-1,j] v_new[1,j] = v_new[2,j] v_new[size,j] = v_new[size-1,j] end # swap new and old u_new, u_old = u_old, u_new v_new, v_old = v_old, v_new end return (u_old, v_old) end . Here is the code in C++. . Click to expand… #include &lt;iostream&gt; #include &lt;random&gt; #include &lt;algorithm&gt; // swap #define N 100 std::random_device rd; std::mt19937 mt(rd()); double fitzhugh_nagumo(double T) { // Define the constants const double aa = 2.8e-4; const double bb = 5.0e-3; const double tau = 0.1; const double kappa = -0.005; const double dx = 2.0 / N; const double dt = 0.9 * dx*dx / 2.0; const double invdx2 = 1.0 / (dx*dx); const double dt_tau = dt / tau; // Random initial fields double u_old[N][N]; double v_old[N][N]; double u_new[N][N]; double v_new[N][N]; std::uniform_real_distribution&lt;double&gt; rng(0.,1.); for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { u_old[i][j] = rng(mt); v_old[i][j] = rng(mt); } } // Solver int Nt = (int) (T / dt); std::cout &lt;&lt; &quot;Nt = &quot; &lt;&lt; Nt &lt;&lt; std::endl; for (int t = 0; t &lt; Nt; ++t) { // evolve inner coordinates for (int i = 1; i &lt; N-1; ++i) { for (int j = 1; j &lt; N-1; ++j) { double delta_u = invdx2 * (u_old[i+1][j] + u_old[i-1][j] + u_old[i][j+1] + u_old[i][j-1] - 4*u_old[i][j]); double delta_v = invdx2 * (v_old[i+1][j] + v_old[i-1][j] + v_old[i][j+1] + v_old[i][j-1] - 4*v_old[i][j]); u_new[i][j] = u_old[i][j] + dt * (aa*delta_u + u_old[i][j] - u_old[i][j]*u_old[i][j]*u_old[i][j] - v_old[i][j] + kappa); v_new[i]After i[j] = v_old[i][j] + dt_tau * (bb * delta_v + u_old[i][j] - v_old[i][j]); } } // neumann boundary conditions for (int i = 0; i &lt; N; ++i) { u_new[i][0] = u_new[i][1]; u_new[i][N-1] = u_new[i][N-2]; v_new[i][0] = v_new[i][1]; v_new[i][N-1] = v_new[i][N-2]; } for (int j = 0; j &lt; N; ++j) { u_new[0][j] = u_new[1][j]; u_new[N-1][j] = u_new[N-2][j]; v_new[0][j] = v_new[1][j]; v_new[N-1][j] = v_new[N-2][j]; } // Swap old and new std::swap(u_new, u_old); std::swap(v_new, v_old); } return u_old[0][0]; } . Results . Setup: . Hardware: Intel(R) Core(TM) i5-3570 CPU @ 3.40GHz (AVX) | Julia version: 0.3.10 | C++ Compiler: g++4.8 | . Language Notes Time (s) . Julia | None | 5.993 | . Julia | @inbounds | 3.105 | . Julia | @inbounds + @simd | 3.0603 | . C++ | -O0 -std=c++11 | 22.790 | . C++ | -Ofast -std=c++11 -fno-tree-vectorize -fno-tree-slp-vectorize | 3.2096 | . C++ | -Ofast -std=c++11 | 2.142 | . The best time in C++ is only 1.4x better than the best time in Julia. Inspecting the ASM of Julia + @inbounds + @simd shows that even with these macros Julia is still not generating vector instructions. :(. If I disable vectorisation in the C++ compiler, the times between Julia and C++ are much closer. This suggests that Julia could get even higher performance if it could generate vector instructions. I suppose that newer versions of Julia will improve this in the future. I find these results very impressive nonetheless. It will be worth trying with a newer LLVM version too. . Notes . The thing holding back performance in the Julia code was the use of u[i,j]^3 instead of u[i,j]*u[i,j]*u[i,j]. The former version compiles to a call of pow(double, double) from libm! The latter does what you expect. This is a known bug. Fixed when Julia is built against LLVM 3.6. Version I’m using is built with LLVM v3.4. .",
            "url": "https://jimypbr.github.io/blog/julia/c++/simd/2015/11/21/julia.html",
            "relUrl": "/julia/c++/simd/2015/11/21/julia.html",
            "date": " • Nov 21, 2015"
        }
        
    
  
    
        ,"post6": {
            "title": "Hello",
            "content": "Typical hello world first blog post… .",
            "url": "https://jimypbr.github.io/blog/2015/11/20/hello.html",
            "relUrl": "/2015/11/20/hello.html",
            "date": " • Nov 20, 2015"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jimypbr.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jimypbr.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}